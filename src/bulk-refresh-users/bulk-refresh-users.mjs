// ==== Adjust the values below to configure the script ====

// 1. Set this to your instance URL.
const instance = 'https://example.com';

// 2. Set this to a moderator's native token.
// An access token may work, but has not been tested.
const token = '';

// 3. (optional) Set API options to filter the list of users.
// You can supply any supported parameter to the /api/admin/show-users endpoint, but please do not include "limit", "offset", or "origin".
// Those values are generated by the script and will cause errors if modified.
const usersFilter = {
	sort: '-createdAt',
	state: 'available',
};

// 4. (optional) Set minimum time in milliseconds between requests to update a user.
// The current Sharkey release supports a maximum of 4 calls per second (250 ms) with default rate limits.
// This can be increased to slow down the process, and therefore reduce server load.
const requestConcurrency = 4;
const requestIntervalMs = 250;

// 5. (optional) Resume an earlier failed run.
// If the script exited early (such as from network trouble), then you can resume where you left off by adjusting this value.
// Scroll back up in the previous output to the last instance of "Updating page from offset ####:" and place that number here.
// The script will resume from that point.

// 6. (optional) Retry failed requests.
// If an API call fails with a network error, then it will be retried.
// You may configure the retry behavior here.
const retryLimit = 3;
const retryBackoff = 1;
const retryStatuses = [429, 501, 502, 503];

// ==== Stop here! Don't touch anything else! ====

try {
	for (let offset = initialOffset;;) {
		console.log(`Updating page from offset ${offset}:`);
		const page = await api('admin/show-users', {
			offset,
			limit: 100,
			origin: 'remote',
			...usersFilter
		});

		// Stop looping when we stop getting results
		if (page.length < 1) break;
		offset += page.length;

		// Process the page at the configured rate
		await updateUsersAtRate(page);
	}
} catch (err) {
	console.error('Failed with unhandled error: ', err);
}

/**
 * @typedef User
 * @property {string} id
 * @property {string} host
 * @property {string} username
 * @property {boolean} isSuspended
 */

/**
 * Drip-feeds background requests to update users from a list.
 * Maintains an average of requestIntervalMs milliseconds between calls.
 * @param page {User[]}
 * @returns {Promise<void>}
 */
async function updateUsersAtRate(page) {
	const controller = new AbortController();
	const promises = [];

	async function thread() {
		let lastStartedAt = 0;
		while (page.length > 0 && !controller.signal.aborted) {
			// Wait for next slot
			const nextSlotStart = lastStartedAt + requestIntervalMs;
			const timeToWait = nextSlotStart - Date.now();
			await timeout(timeToWait, controller.signal);

			// Track run
			lastStartedAt = Date.now();

			// Execute
			const success = await updateNextUser(page, controller.signal);
			if (!success) {
				controller.abort('aborting');
			}
		}
	}

	for (let i = 0; i < requestConcurrency; i++) {
		promises.push(thread());
	}

	await Promise.all(promises);
}

/**
 * @param {User[]} page
 * @param {AbortSignal} [signal] Optional abort signal
 * @returns {Promise<boolean>}
 */
async function updateNextUser(page, signal) {
	const user = page.shift();
	if (!user) return false;

	if (user.isSuspended) {
		console.log(`Not updating user ${user.id} (${user.username}@${user.host}): user is suspended`);
		return true;
	}

	await api('federation/update-remote-user', { userId: user.id }, signal)
		.then(() => console.log(`Successfully updated user ${user.id} (${user.username}@${user.host})`))
		.catch(err => console.log(`Failed to update user ${user.id} (${user.username}@${user.host}):`, err))
	;
	return true;
}

/**
 * Makes a POST request to Sharkey's API with automatic credentials and rate limit support.
 * @param {string} endpoint API endpoint to call
 * @param {unknown} [body] Optional object to send as API request payload
 * @param {AbortSignal} [signal] Optional abort signal
 * @param {number} [attempt] Do not use - for retry purposes only
 * @returns {Promise<unknown>}
 */
async function api(endpoint, body = {}, signal, attempt = 1) {
	try {
		const res = await fetch(`${instance}/api/${endpoint}`, {
			method: 'POST',
			headers: {
				Accept: 'application/json',
				Authorization: `Bearer ${token}`,
				'Content-Type': 'application/json',
			},
			body: JSON.stringify(body),
		});

		// Check for rate limit
		if (retryStatuses.includes(res.status) && attempt < retryLimit) {
			const reset = res.headers.get('X-RateLimit-Reset');
			const delay = reset ? Number.parseFloat(reset) : retryBackoff;
			await timeout(delay * 1000, signal);
			return await api(endpoint, body, attempt + 1);
		}

		// Fucky way of handling any possible response through one code path
		if (res.ok) {
			const contentType = res.headers.get('Content-Type');
			if (!contentType) return undefined;
			if (contentType.startsWith('application/json')) return await res.json();
			if (contentType.startsWith('text/')) return await res.text();
			throw `Unsupported Content-Type: ${contentType}`
		} else {
			throw `${res.status} ${res.statusText}`;
		}
	} catch (err) {
		throw String(err);
	}
}

/**
 * Returns a promise that resolves after the specified time, or rejects when the given signal aborts
 * @param {number} timeToWait
 * @param {AbortSignal} [signal]
 * @returns {Promise<void>}
 */
async function timeout(timeToWait, signal) {
	if (timeToWait < 1) {
		return;
	}

	await new Promise((resolve, reject) => {
		if (signal) {
			signal.addEventListener('abort', reject);
		}
		setTimeout(() => {
			if (signal) {
				signal.removeEventListener('abort', reject);
			}
			resolve();
		}, timeToWait);
	});
}