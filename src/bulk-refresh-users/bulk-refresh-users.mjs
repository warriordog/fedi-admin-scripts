// ==== Adjust the values below to configure the script ====

// 1. Set this to your instance URL.
const instance = 'https://example.com';

// 2. Set this to a moderator's native token.
// An access token may work if it has "View private user info" permission.
const token = '';

// 3. (optional) Set API options to filter the list of users.
// You can supply any supported parameter to the /api/admin/show-users endpoint, but please do not include "limit", "offset", or "origin".
// Those values are generated by the script and will cause errors if modified.
const usersFilter = {
	sort: '-createdAt',
	state: 'available',
};
// Skip users who have been updated within this many milliseconds ago.
const minimumOutdatedTime = 0;

// 4. (optional) Set minimum time in milliseconds between requests to update a user.
// The current Sharkey release supports a maximum of 4 calls per second (250 ms) with default rate limits.
// This can be increased to slow down the process, and therefore reduce server load.
const requestIntervalMs = 250;

// 5. (optional) Resume an earlier failed run.
// If the script exited early (such as from network trouble), then you can resume where you left off by adjusting this value.
// Scroll back up in the previous output to the last instance of "Updating page from offset ####:" and place that number here.
// The script will resume from that point.
const initialOffset = 0;

// 6. (optional) Retry failed requests.
// If an API call fails with a network error, then it will be retried.
// You may configure the retry behavior here.
const retryLimit = 3;
const retryBackoff = 1;
const retryStatuses = [429, 501, 502, 503];

// 7. (optional) Reduce overhead
// These options can reduce the amount of data transferred and fetched by the backend.
// Older sharkey versions do not support them and may return errors.
const returnLiteUser = false;

// ==== Stop here! Don't touch anything else! ====

class ResponseError extends Error {
	/**
	 * @param {Response} response
	 * @param {string} [message]
	 */
	constructor(response, message) {
		super(message);
		this.response = response;
	}
}

class StatusError extends ResponseError {
	/**
	 * @param {Response} response
	 * @param {string} [message]
	 */
	constructor(response, message) {
		super(response, message ?? `Request failed with status ${response.status} ${response.statusText}`);
		this.statusCode = response.status;
		this.statusText = response.statusText;
	}
}

class ContentTypeError extends ResponseError {
	/**
	 * @param {Response} response
	 * @param {string} [message]
	 */
	constructor(response, message) {
		super(response, message ?? `Unsupported content-type ${response.headers.get('Content-Type')}`);
		this.contentType = response.headers.get('Content-Type');
	}
}

let offset = initialOffset;

process.on('SIGINT', () => process.exit(-1));

process.on('exit', code => {
	if (code === 0) {
		console.log(`Completed at offset ${offset}`);
	} else if (code === -1) {
		console.error(`Terminated at offset ${offset}.`);
	} else if (offset >= 100) {
		console.error(`Failed at offset ${offset}. Last successful offset: ${offset - 100}.`);
	} else {
		console.error(`Failed at offset ${offset}.`);
	}
});

try {
	while (true) {
		console.log(`Updating page from offset ${offset}:`);

		/** @type {User[]} */
		const page = await api('admin/show-users', {
			offset,
			limit: 100,
			origin: 'remote',
			detail: returnLiteUser ? false : undefined,
			...usersFilter
		});

		// Page gets muted by updateUsersAtRate so we have to check it here!
		const pageLength = page.length;

		// Stop looping when we reach the end
		if (pageLength < 1) {
			break;
		}

		// Process the page at the configured rate
		await updateUsersAtRate(page);

		// Update offset *after* success
		offset += pageLength;
	}
} catch (err) {
	console.error('Failed with unhandled error: ', err);
}

/**
 * @typedef User
 * @property {string} id
 * @property {string} host
 * @property {string} username
 * @property {boolean} isSuspended
 * @property {string} createdAt
 * @property {string | null} [updatedAt]
 * @property {string | null} [lastFetchedAt]
 */

/**
 * Drip-feeds background requests to update users from a list.
 * Maintains an average of requestIntervalMs milliseconds between calls.
 * @param page {User[]}
 * @returns {Promise<void>}
 */
async function updateUsersAtRate(page) {
	const promises = [];
	let delay = 0;

	while (page.length > 0) {
		// Temporary delays like a rate limit
		await timeout(delay);
		delay = 0;

		const user = page.shift();

		if (user.isSuspended) {
			console.log(`Skipping user ${user.id} (${user.username}@${user.host}): user is suspended`);
			continue;
		}

		const dates = [user.lastFetchedAt, user.updatedAt, user.createdAt]
			.filter(d => d != null)
			.map(d => new Date(d).valueOf());
		const updatedAt = Math.max(...dates);
		if (Date.now() - updatedAt < minimumOutdatedTime) {
			console.log(`Skipping user ${user.id} (${user.username}@${user.host}): user is recently updated`);
			continue;
		}

		const promise = updateNextUser(user).catch(err => {
			// Check for retryable errors
			if (err instanceof StatusError && retryStatuses.includes(err.statusCode)) {
				const reset = err.response.headers.get('X-RateLimit-Reset');
				const backoff = reset ? Number.parseFloat(reset) : retryBackoff;

				delay += backoff;
				page.push(user);
			}

			// Check for network errors
			if (err instanceof Error && err.name === 'FetchError') {
				delay += retryBackoff;
				page.push(user);
			}

			// TODO limit retires
		});
		promises.push(promise);

		// Standard delay between calls
		await timeout(requestIntervalMs);
	}

	await Promise.allSettled(promises);
}

/**
 * @param {User} user
 * @returns {Promise<void>}
 */
async function updateNextUser(user) {
	try {
		await api('federation/update-remote-user', { userId: user.id });
		console.log(`Successfully updated user ${user.id} (${user.username}@${user.host})`);
	} catch (err) {
		console.log(`Failed to update user ${user.id} (${user.username}@${user.host}):`, String(err));
		throw err;
	}
}

/**
 * Makes a POST request to Sharkey's API with automatic credentials and rate limit support.
 * @template T return type
 * @param {string} endpoint API endpoint to call
 * @param {unknown} [body] Optional object to send as API request payload
 * @returns {Promise<T>}
 */
async function api(endpoint, body = {}) {
	const res = await fetch(`${instance}/api/${endpoint}`, {
		method: 'POST',
		headers: {
			Accept: 'application/json',
			Authorization: `Bearer ${token}`,
			'Content-Type': 'application/json',
		},
		body: JSON.stringify(body),
	});

	// Errors
	if (!res.ok) {
		throw new StatusError(res);
	}

	// No content
	if (res.status === 204) {
		return undefined;
	}

	// Fucky way of handling any possible response through one code path
	const contentType = res.headers.get('Content-Type');
	if (!contentType) return undefined;
	if (contentType.startsWith('application/json')) return await res.json();
	if (contentType.startsWith('text/')) return await res.text();
	throw new ContentTypeError(res);
}

/**
 * Returns a promise that resolves after the specified time, or rejects when the given signal aborts
 * @param {number} timeToWait
 * @param {AbortSignal} [signal]
 * @returns {Promise<void>}
 */
async function timeout(timeToWait, signal) {
	if (timeToWait < 1) {
		return;
	}

	await new Promise((resolve, reject) => {
		if (signal) {
			signal.addEventListener('abort', reject);
		}
		setTimeout(() => {
			if (signal) {
				signal.removeEventListener('abort', reject);
			}
			resolve();
		}, timeToWait);
	});
}